package errors

import (
	"bytes"
	"fmt"
	"path/filepath"
	"runtime"

	status "google.golang.org/grpc/status"
)

// Constants for use with SetVerbosity(...)
const (
	Info = iota
	Verbose
	Debug
	Trace
)

// verbosity variable stores global verbosity setting for errors package
// based on it's value different level of error details will be provided
// by Error, Errorf, Json and Jsonf
var verbosity int

// SetVerbosity changes global verbosity setting.
func SetVerbosity(v int) { verbosity = v }

// An Error represents a network error.
type netError interface {
	error
	Timeout() bool
	Temporary() bool
	GetCode() int
	GetMessage() string
	GetCause() error
	GetStack() stack
	GRPCStatus() *status.Status
}

// stackFrame represents a single frame of a stack trace
type stackFrame struct {
	file     string
	line     int
	function string
}

// stack is a slice of stackFrames representing a stack trace
type stack []stackFrame

// String generates a string representation of a stack trace generated by
// getTrace
func (s stack) String() string {
	var buffer bytes.Buffer
	for i := 0; i < len(s); i++ {
		if s[i].file == "<autogenerated>" {
			break
		}
		buffer.WriteString(fmt.Sprintf("\n%s:%d %s", s[i].file, s[i].line, s[i].function))
	}
	return buffer.String()
}

// getTrace generates trace
func getTrace() stack {

	var stack stack
	stack = make([]stackFrame, 0)

	for i := 2; ; i++ {
		pc, fn, line, ok := runtime.Caller(i)
		if !ok {
			// no more frames - we're done
			break
		}
		_, fn = filepath.Split(fn)

		f := stackFrame{file: fn, line: line, function: funcName(pc)}
		stack = append(stack, f)
	}

	return stack
}

// funcName gets the name of the function at pointer or "Unknown function." if one can't be found
func funcName(pc uintptr) string {
	if f := runtime.FuncForPC(pc); f != nil {
		return f.Name()
	}
	return "Unknown function."
}

// errorStr returns a string representation of netError.
func errorStr(e netError) string {

	switch verbosity {
	case 0:
		return fmt.Sprintf("error %d: %s", e.GetCode(), e.GetMessage())
	case 1:
		cause := e.GetCause()
		if cause == nil {
			return fmt.Sprintf("error %d: %s", e.GetCode(), e.GetMessage())
		}
		return fmt.Sprintf("error %d: %s\ncause: %s", e.GetCode(), e.GetMessage(), cause.Error())
	case 2:
		stack := e.GetStack()
		cause := e.GetCause()
		if cause == nil {
			if stack[0].file != "<autogenerated>" {
				return fmt.Sprintf("%s:%d: error %d: %s", stack[0].file, stack[0].line, e.GetCode(), e.GetMessage())
			}
			return fmt.Sprintf("error %d: %s", e.GetCode(), e.GetMessage())
		}
		if stack[0].file != "<autogenerated>" {
			return fmt.Sprintf("%s:%d: error %d: %s\ncause: %s", stack[0].file, stack[0].line, e.GetCode(), e.GetMessage(), cause.Error())
		}
		return fmt.Sprintf("error %d: %s\ncause: %s", e.GetCode(), e.GetMessage(), cause.Error())
	default:
		stack := e.GetStack()
		cause := e.GetCause()
		if cause == nil {
			if stack[0].file != "<autogenerated>" {
				return fmt.Sprintf("%s:%d: error %d: %s\nstack:%s", stack[0].file, stack[0].line, e.GetCode(), e.GetMessage(), stack.String())
			}
			return fmt.Sprintf("error %d: %s\nstack: %s", e.GetCode(), e.GetMessage(), stack.String())
		}
		if stack[0].file != "<autogenerated>" {
			return fmt.Sprintf("%s:%d: error %d: %s\ncause: %s\nstack:%s", stack[0].file, stack[0].line, e.GetCode(), e.GetMessage(), cause.Error(), stack.String())
		}
		return fmt.Sprintf("error %d: %s\ncause: %s\nstack:%s", e.GetCode(), e.GetMessage(), cause.Error(), stack.String())
	}
}
